二、调度器在内核态

某一时刻,系统中,进程,线程,协程的状态.(kpti)
一个内核进程(内核本身)
多个常驻内核态的内核协程(均由调度器接口创建)
多个用户进程(由内核提供的接口创建),每个用户进程下包含多个用户线程(由调度器接口创建),每个用户线程下由多个用户协程(由调度器接口创建),这些用户进程会在运行时不断在用户进程与内核进程中反复横跳

注：内核调度器与用户态的调度器的区别：当前协程的退出操作会不同（最后一个内核协程退出会进入IDLE）

# 2.1. 调度的对象

**用户进程 内核线程 内核协程 用户线程 用户协程(不直接参与调度)**


# 2.2 调度的目标

协程被强制切换,需要保存堆栈

协程主动让权,可以不保存堆栈.

系统总体使用堆栈数目 = cpu个数 + 被强制切换协程的数量

如果主动让权的多了总体使用堆栈数目就会减少

所以目标是:当有优先级更高的协程存在时, 低优先级的协程尽可能的主动让出,而不是被强制切换. 从而达到系统总体使用的堆栈数目减少.


more:还需细化

# 2.2. 各对象具体的调度方式

1.用户进程队列,内核线程队列,内核协程队列,与内核在同一页表下,内核可以直接拿到其数据

2.用户线程,用户协程与内核属于不同地址空间


**用户进程**
目前执行一个调度循环. 不断从进程队列中取出进程执行
todo:进程不再是调度的单位

**内核线程**
内核线程平时执行一个idle_main,  idle_main不断从线程池中获取一个可运行的线程.
当线程池没有任何可运行的线程,则会检查协程队列,如果还有协程新加入,则创建一个线程包含协程执行器继续运行, 如果空,则退出.
退出方式:
1.继续运行idle_main
2.使当前cpu进入低功耗状态(spin_loop)

**内核协程**
内核协程主要执行异步系统调用,并根据实时性要求不同设置不同的优先级.由协程runtime调度.

todo:时钟中断到来时检查用户线程是否需要让权（其他用户线程中是否有优先级更高的协程

**用户线程**
用户线程为内核参与用户协程调度的载体. 内核需处理用户线程退出的情况,回收其cpu资源.

**用户协程**
获取最高优先级协程所在的地址空间. 并且提示下一个用户线程, 让它主动让出cpu,这便少了一次堆栈的保存和恢复.  可能的情况---最高优先级协程所在线程已经占有cpu资源



# 2.3 
区分用户态和内核态方式进程id,
负载均衡放到协程中完成.
协程切换：进程对应地址空间切换、线程切换对应抢占式协程切换、协程主动让权切换；
